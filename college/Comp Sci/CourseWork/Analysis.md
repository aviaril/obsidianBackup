Hamish Lindsay
[[Goose Chase]]
#### Introduction
This is the Write-up for a student project that is a game where the player is a goose flying to and trying to solve puzzles in order to solve a murder mystery. 
#### Description
I have decided to make a puzzle game centred around the mechanics of a bird flying. The player will play as a goose solving puzzles in order to collect clues for a murder case, as this is project is a prototype instead of a full game the murder plot will not be solvable however if I was making this into a full game solving the murder would be the main goal for the player. The game will take place across several floating islands, each with their own puzzle on them, surrounding a larger main island where the murder took place. The gameplay loop will consist of the player being given a hint by one of the people on the main island that will lead the player to one of the secondary islands where they will be presented with a puzzle to solve, once they have solved the puzzle the player can fly back to the main island and get another hint. The player will travel between islands using flight system based on the unity physics system, the player will be able to flap to gain speed at the expense of a cooldown (having to wait a while before they can flap again) or glide, while gliding the player will be able to change the yaw and pitch of the bird to steer but any changes to the roll will be purely cosmetic, if the player pitches the bird down far enough it will enter a dive gaining speed in exchange for hight. If the player gets too far under the islands and will not be able to get back up the game will revert to the point they took off from, preventing softlocks (a state where the game is technically playable but the player cannot progress) this feature can also be manually activated by the player in the pause menu. There will also be a pause menu available to the player called the notebook, it will be made up of several submenus called pages, these will include a pause menu where the player can revert to last take-off,  save the game, exit the game, and view the control scheme (I might add the ability to remap the controls but currently this is not a priority). There will also be pages for a map of the game, a page for hints to the current puzzle and a list of puzzles that the player has already completed (I would also like to add some options for player customisation allowing the player to alter how the character looks, potentially with hats or alternative colour schemes however this will most likely be cut from the game). The game will be in third person with the camera orbiting the player at a set distance, although the user can change between three pre-set distances from the player-model. 

#### Computational methods
###### Abstraction 
My target audience will likely be playing on rather low-end hardware meaning my game will have less resources available to it, In particular I am aiming to reduce the GPU usage as this is usually the biggest limitation of playing games on low end computers. One method of doing this is Abstraction, when you remove unnecessary detail from a problem to reduce the time and effort needed to solve the problem. The main ways this project will be using abstraction is the use of single colours in place of textures, this will mean the system will not have to render high definition textures resulting in more systems being able to run the game and thus more players being able to play. 
Another example of Abstraction in my project is the use of low-poly models as they require the computer to render less geometry, this is for the same reasons as the lack of textures, to make the game run better and to contribute to the art style.
Another way I will be using abstraction is the use of additive level loading, in my proposed implementation of the method it means that parts of the game are only loaded when they enter the players field of view or when the player get too close to them instead of loading the entire game at once, this means there will be less for the system to render and simulate without the player noticing a difference in gameplay, it also allows these zones to be unloaded from the system memory 
##### Thinking ahead
My program will need inputs from the keyboard and mouse, to be specific the WASD keys and SPACE will be used for movement and the mouse to control the camera with E being used to interact with objects and TAB being used to bring up the map. W will be used to move the player forward while walking and to tilt up while flying, A will be used to move left while walking and to yaw left while flying (although this may be hanged to yaw right later into development depending on how it feels or player preference), S will be used to move backwards or to tilt down and dive while flying, D will be used to walk right and to yaw right while flying (although this may also be reversed). Space will be used to jump while walking by adding a positive force to the player in the Y axis, SPACE will also be used to flap while the player is flying accomplished by a similar method to jumping however another force will be added in the direction the player is facing. TAB will open the notebook to the map page, from here the player can either turn to another page as normal or can press the TAB key again to close the notebook. The mouse buttons will most likely only be used to navigate the menus however the mouse movements will be used to move the camera orbiting the player, moving the mouse vertically i.e. towards or away from the user will move the camera up or down around the player model and moving the mouse horizontally will move the camera around the player in a horizontal ring. 
The player will obviously need a monitor to play the game however the resolution should not matter as I will add options to adjust the resolution the game is rendered in. The player may want speakers or headphones to play the game as there will be simple sound effects however this will not be necessary to play the game. 
I will be using the Unity scripting API, in particular I will be using the force and translate functions to move the player and any object that need to be moved, this will save me from having to write functions to move objects myself thus allowing me to get more done. I will also be writing my own functions for things such as save and autosave features, these will be reused all over the game and triggered by the player for the Save and the autosave will be called when the player progresses in a puzzle. 
Parts of programs need to be reused for the sake of efficiency both on the programmers part not having to re-write sections of code every time they need to be used and for the sake of the program where masses of repeated code would have to be compiled, wasting CPU time and increasing load times for the project. 
##### Divide and conquer 
The notebook/menu will have a list of steps in solving a puzzle that the player has completed, this will help the player to remember where they were if they continue a save or just if they get confused as to what to do next they can look at what they have done previously to help them think of what to do next. This will be accomplished by using an array with the elements acting as Boolean flags to find what to display to the player, the last flag that is high will be read and then all strings indicated by the flags before it will be printed in the menu. In order to find the final flag I will be using an algorithm similar to a binary search, the algorithm will start by finding the halfway point of the array and reading the value of the element, if the flag is high the algorithm will read the element to the right of the current element and if that is low the algorithm has found the last high flag, if this second element is high the algorithm will find the halfway point between the end of the array and the current element then repeat the process. If the first halfway point is low the algorithm will find the halfway point between the start of the array and the current element and then repeat the process until it finds the last high flag. 
#### Research
##### AER
![[aer.jpg]]
I have drawn inspiration from a game called AER: memories of old (developed by Forgotten Key). In this game you solve puzzles located on floating islands that you fly to as a bird, the main focus and appeal of the game is on the flight system with the puzzles being used as a destination to fly to and a break from flying to prevent the game becoming boring. The main audience for this game is casual gamers aged seven and up, I feel this broad target audience is reached through the use of intuitive movement and a lack of a complicated story or much dialogue making the game easy to enjoy for young players who will pick it up quickly and not have to bother with reading dialogue which they may not have an interest in as well as older players who may be attracted by the fact that they do not have to invest a large amount of time to learn the controls or have to invest a large amount of time into understanding a complex story. AER uses a form of abstraction in its very minimal art style, this helps to optimise the game as the system does not need to render high resolution textures or complex geometry instead only having to render simple models and flat colours, allowing it to run on more systems and therefor reach a larger audience.

I also enjoyed the flight system in the game that allows the player to steer, dive and flap however I did feel that it could be a little unengaging to use as the bird will not fall if left to it's own devices, at times this made the flight a little boring as there are very few things that need to be managed in order to use it. It also reduces the opportunity to improve at the game which is something I among many others enjoy about games, this may reduce the users enjoyment of the game. 

One thing I dislike about the game is the lack of direction, because the game lacks a complex story and a lot of exposition finding the place to go next can feel confusing and at times I felt lost while playing, this problem is mostly overcome with the use of the games map however finding the next puzzle can still feel unintuitive as the puzzles are not marked on the map and the player is not give any hints to the location of the puzzles. 

I have decided that I will use a flight system similar to AER's but to address my issue I will adding an additional input required to keep the bird in the air, this should make the flight more engaging for the player and improve their experience with the game. I will also be using similar forms of abstraction to AER with the simple colours instead of textures and the low-poly models. I will also be giving the players hints as to where they need to go and making the locations of the puzzles far more obvious 

##### Portal
![[portal.jpg]]
Portal (developed by VAlVe software) is a game released in 2007 with a target audience of adolescents through to adults.  In Portal the player is given the ability to create two portals that are linked together so if the player walks through one they will walk out of the other, the player can also move object through said portals allowing for far more complexity and more interesting
puzzles as a result, despite sounding complex the gameplay is surprisingly intuitive but still opens up an entirely new way of approaching problems encouraging the player to become more interested in the game and completing it. In other games the ability to teleport is often seen only as a way to move from point A to B, however Portal's use of this mechanic as a necessity to solve puzzles makes the player rethink the mechanic and
how to use it resulting in the player "Thinking outside the box" this, in-turn makes the user feel that the game is more
interactive improving their experience. Portal also gradually introduces the player to the mechanics instead of throwing everything at them at once the player is first shown how portals work by allowing them to use portals already placed in the world and moved in a pre-determined pattern only later in the game is the player given the ability to choose when and where the portals are placed, this allows the player to learn how to
use the portals without overwhelming them by making them consider how they need to be placed, it also ensures the
mechanic does not become boring by adding to it just as the previous version starts to get repetitive.

I enjoy the use of a traditionally movement based mechanic as a puzzle solving tool and the affect that has on the player, making them engage with the puzzles more. I also enjoyed the emergent gameplay (when the players find techniques and tricks that were not directly intended by the developer but that contribute to the depth and complexity of the game) that came from giving the players so much freedom when solving the puzzles.

One thing I dislike about PORTAL is the actually one of its strengths, the delay before the player is given access to all of the features of the game; While it prevents the gameplay from getting stale and prevents the player from being overwhelmed it can feel that the moveable portals are being held back for too long especially for players on their  player is missing out on some of the fun they could have had if they had access to the movable portals from the start or at least if they had been given them earlier. Withholding mechanics can also make the game feel too slow to progress as the game has to slow down the pace for a bit every time they introduce a new mechanic as the player needs time to familiarise themselves with the mechanic, this can lead to the game feeling disjointed and almost awkward in some examples as the players immersion can be broken if it feels like they are being made to play a tutorial every 30 minutes. 

I will use the concept of a movement mechanic being used as a main feature in solving puzzles and I will use the approach of introducing mechanics piecemeal to prevent the player from being overwhelmed and to ensure that they know how the mechanics work, however I will be introducing the mechanics faster than PORTAL did in order to prevent players from feeling that they are missing out on gameplay with the mechanic.  
##### Subnautica 
![[subnautica.jpg]]
I dislike how linear some puzzle games can be as it reduces the amount of impact the player feels they have on the
game if no matter what they chose to do they are always doing things in the same order, however there needs to be
some method of restricting the player otherwise they could just skip all of the gameplay and go straight to the end.
One method of doing this is by adding checks dictating when a player can go at what time, i.e. the player can go to
any of the puzzles when they want but are not allowed to solve it before another has been solved, however this can
feel just as linear as if the player couldn't even see the puzzle that they aren't allowed to solve. One approach that I
do like is by allowing the player to do what they want when they want to but making the things that should be done later
much harder to do and then giving the player things to make it easier later in the game. One game I think is a very
good example of this is Subnautica by Unknown Worlds entertainment, Subnautica is an open-world survival game
set in an alien ocean planet that the player crashed on, the goal of the game is to leave the planet but at the
start of the game the player has no way of doing this, after exploring the player will eventually find blueprints for a
rocket that they can build however due to both story reasons and the resource requirement to build the rocket the
player has to go to the deepest section of the game before they can build the rocket and finish the game, to prevent
players from completing the story too quickly there are several factors preventing the player from just swimming to the
required area, these are mainly the depth of the objectives being to deep to swim to without a vehicle and the early
game vehicles not being able to go deep enough to get to the main objectives. This makes the player explore enough
to get the late game vehicles and be able to complete the story.

I like the approach Subnautica takes to prevent the game from feeling too linear however the game still has some hard limits to it's progression (hard limits meaning the player must do X before the can do Y), this can result in the game feeling linear despite the efforts of the developers to remove this feeling. 

I have decided that I will make my project as non-linear as possible as to give the player the most freedom and hopefully improve their experience with the game. I will do this by making the puzzles individual obstacles that do not need to be solved in any particular order, each puzzle would give the player a clue to who the murderer is but would not tell the player where to look for the next clue (although this may be implied), instead after each puzzle the player would return to the main island and would be able to choose another puzzles to solve. 

#### Target Audience
My target audience is consists of casual gamers of all ages, this is a very wide demographic to fill with the only real connection being an interest in video games but due to any number of reasons would not be investing much time or money into them, they will likely play videogames decently often but will not be massively interested in competitive games or games with a large time or monetary investment i.e. they would not be buying a racing sim rig to play a racing game instead most likely playing on a controller. These players are quite likely to be console players, this means they would be unable to play my game as it will only be available on PC. The remaining people who are using a PC will likely be playing on rather low-end hardware and as such the system will not have an enormous amount of resources available to run the game meaning that my project will have to be well optimised.

These players should enjoy the easy to pick up nature of my game and the lack of time investment needed to enjoy it that is so often seen in other games, they should also like that the full game would still be quite short as this will allow them to experience the sull story without a large time investment which they may not be able to give due to work, school or other responsibilities. 

#### Requirements
##### Hardware
- 64bit x86 CPU with support for the SSE2 instruction set 
- Support for DirectX 10 or later
- mouse
- Keyboard
##### Software
- Windows 7 and up 
- Visual studio code 2015 with the C++ components installed 

#### Limitations 
1. The low-end hardware I am targeting means that I will not be able to have graphically intense shaders, these often have a very large affect on the perceived graphical quality of a game and not using them does limit me in how the game will look
2. The fact that the game will only be available on PC and not mobile or console will limit the amount of players who can play it
3. There is a limited scope as this project is only a prototype instead of a full game
# Class diagram
![[Design]]